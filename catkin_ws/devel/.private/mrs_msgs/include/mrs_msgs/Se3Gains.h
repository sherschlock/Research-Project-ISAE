// Generated by gencpp from file mrs_msgs/Se3Gains.msg
// DO NOT EDIT!


#ifndef MRS_MSGS_MESSAGE_SE3GAINS_H
#define MRS_MSGS_MESSAGE_SE3GAINS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mrs_msgs
{
template <class ContainerAllocator>
struct Se3Gains_
{
  typedef Se3Gains_<ContainerAllocator> Type;

  Se3Gains_()
    : kpxy(0.0)
    , kvxy(0.0)
    , kaxy(0.0)
    , kpz(0.0)
    , kvz(0.0)
    , kaz(0.0)
    , kqxy(0.0)
    , kibxy(0.0)
    , kibxy_lim(0.0)
    , kiwxy(0.0)
    , kiwxy_lim(0.0)
    , kqz(0.0)
    , km(0.0)
    , km_lim(0.0)  {
    }
  Se3Gains_(const ContainerAllocator& _alloc)
    : kpxy(0.0)
    , kvxy(0.0)
    , kaxy(0.0)
    , kpz(0.0)
    , kvz(0.0)
    , kaz(0.0)
    , kqxy(0.0)
    , kibxy(0.0)
    , kibxy_lim(0.0)
    , kiwxy(0.0)
    , kiwxy_lim(0.0)
    , kqz(0.0)
    , km(0.0)
    , km_lim(0.0)  {
  (void)_alloc;
    }



   typedef double _kpxy_type;
  _kpxy_type kpxy;

   typedef double _kvxy_type;
  _kvxy_type kvxy;

   typedef double _kaxy_type;
  _kaxy_type kaxy;

   typedef double _kpz_type;
  _kpz_type kpz;

   typedef double _kvz_type;
  _kvz_type kvz;

   typedef double _kaz_type;
  _kaz_type kaz;

   typedef double _kqxy_type;
  _kqxy_type kqxy;

   typedef double _kibxy_type;
  _kibxy_type kibxy;

   typedef double _kibxy_lim_type;
  _kibxy_lim_type kibxy_lim;

   typedef double _kiwxy_type;
  _kiwxy_type kiwxy;

   typedef double _kiwxy_lim_type;
  _kiwxy_lim_type kiwxy_lim;

   typedef double _kqz_type;
  _kqz_type kqz;

   typedef double _km_type;
  _km_type km;

   typedef double _km_lim_type;
  _km_lim_type km_lim;





  typedef boost::shared_ptr< ::mrs_msgs::Se3Gains_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mrs_msgs::Se3Gains_<ContainerAllocator> const> ConstPtr;

}; // struct Se3Gains_

typedef ::mrs_msgs::Se3Gains_<std::allocator<void> > Se3Gains;

typedef boost::shared_ptr< ::mrs_msgs::Se3Gains > Se3GainsPtr;
typedef boost::shared_ptr< ::mrs_msgs::Se3Gains const> Se3GainsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mrs_msgs::Se3Gains_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mrs_msgs::Se3Gains_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mrs_msgs::Se3Gains_<ContainerAllocator1> & lhs, const ::mrs_msgs::Se3Gains_<ContainerAllocator2> & rhs)
{
  return lhs.kpxy == rhs.kpxy &&
    lhs.kvxy == rhs.kvxy &&
    lhs.kaxy == rhs.kaxy &&
    lhs.kpz == rhs.kpz &&
    lhs.kvz == rhs.kvz &&
    lhs.kaz == rhs.kaz &&
    lhs.kqxy == rhs.kqxy &&
    lhs.kibxy == rhs.kibxy &&
    lhs.kibxy_lim == rhs.kibxy_lim &&
    lhs.kiwxy == rhs.kiwxy &&
    lhs.kiwxy_lim == rhs.kiwxy_lim &&
    lhs.kqz == rhs.kqz &&
    lhs.km == rhs.km &&
    lhs.km_lim == rhs.km_lim;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mrs_msgs::Se3Gains_<ContainerAllocator1> & lhs, const ::mrs_msgs::Se3Gains_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mrs_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mrs_msgs::Se3Gains_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mrs_msgs::Se3Gains_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mrs_msgs::Se3Gains_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8f0afd0f6c3244e7db3d1f6e5db85f04";
  }

  static const char* value(const ::mrs_msgs::Se3Gains_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8f0afd0f6c3244e7ULL;
  static const uint64_t static_value2 = 0xdb3d1f6e5db85f04ULL;
};

template<class ContainerAllocator>
struct DataType< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mrs_msgs/Se3Gains";
  }

  static const char* value(const ::mrs_msgs::Se3Gains_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This a set of gains for the SE(3) controller.\n"
"\n"
"# Horizontal position gain.\n"
"float64 kpxy\n"
"\n"
"# Horizontal velocity gain.\n"
"float64 kvxy\n"
"\n"
"# Horizontal acceleration gain.\n"
"float64 kaxy\n"
"\n"
"# Vertical position gain.\n"
"float64 kpz\n"
"\n"
"# Vertical velocity gain.\n"
"float64 kvz\n"
"\n"
"# Vertical acceleration gain.\n"
"float64 kaz\n"
"\n"
"# Roll+pitch attitude gain.\n"
"float64 kqxy\n"
"\n"
"# Body disturbance gain.\n"
"float64 kibxy\n"
"\n"
"# Body disturbance estimator limit ([N]).\n"
"float64 kibxy_lim\n"
"\n"
"# World disturbance gain.\n"
"float64 kiwxy\n"
"\n"
"# World disturbance estimator limit  ([N]).\n"
"float64 kiwxy_lim\n"
"\n"
"# Yaw attitude gain.\n"
"float64 kqz\n"
"\n"
"# Mass estimator gain.\n"
"float64 km\n"
"\n"
"# Mass estimator limit ([m]).\n"
"float64 km_lim\n"
;
  }

  static const char* value(const ::mrs_msgs::Se3Gains_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.kpxy);
      stream.next(m.kvxy);
      stream.next(m.kaxy);
      stream.next(m.kpz);
      stream.next(m.kvz);
      stream.next(m.kaz);
      stream.next(m.kqxy);
      stream.next(m.kibxy);
      stream.next(m.kibxy_lim);
      stream.next(m.kiwxy);
      stream.next(m.kiwxy_lim);
      stream.next(m.kqz);
      stream.next(m.km);
      stream.next(m.km_lim);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Se3Gains_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mrs_msgs::Se3Gains_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mrs_msgs::Se3Gains_<ContainerAllocator>& v)
  {
    s << indent << "kpxy: ";
    Printer<double>::stream(s, indent + "  ", v.kpxy);
    s << indent << "kvxy: ";
    Printer<double>::stream(s, indent + "  ", v.kvxy);
    s << indent << "kaxy: ";
    Printer<double>::stream(s, indent + "  ", v.kaxy);
    s << indent << "kpz: ";
    Printer<double>::stream(s, indent + "  ", v.kpz);
    s << indent << "kvz: ";
    Printer<double>::stream(s, indent + "  ", v.kvz);
    s << indent << "kaz: ";
    Printer<double>::stream(s, indent + "  ", v.kaz);
    s << indent << "kqxy: ";
    Printer<double>::stream(s, indent + "  ", v.kqxy);
    s << indent << "kibxy: ";
    Printer<double>::stream(s, indent + "  ", v.kibxy);
    s << indent << "kibxy_lim: ";
    Printer<double>::stream(s, indent + "  ", v.kibxy_lim);
    s << indent << "kiwxy: ";
    Printer<double>::stream(s, indent + "  ", v.kiwxy);
    s << indent << "kiwxy_lim: ";
    Printer<double>::stream(s, indent + "  ", v.kiwxy_lim);
    s << indent << "kqz: ";
    Printer<double>::stream(s, indent + "  ", v.kqz);
    s << indent << "km: ";
    Printer<double>::stream(s, indent + "  ", v.km);
    s << indent << "km_lim: ";
    Printer<double>::stream(s, indent + "  ", v.km_lim);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MRS_MSGS_MESSAGE_SE3GAINS_H
