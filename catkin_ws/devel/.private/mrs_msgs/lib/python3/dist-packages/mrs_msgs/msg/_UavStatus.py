# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from mrs_msgs/UavStatus.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import mrs_msgs.msg
import std_msgs.msg

class UavStatus(genpy.Message):
  _md5sum = "96b2a311d1a3f116c9cce438b1893925"
  _type = "mrs_msgs/UavStatus"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header

string uav_name
string nato_name
string uav_type
string uav_mass

float32 control_manager_diag_hz
int16 control_manager_diag_color
string[] controllers
string[] gains
string[] trackers
string[] constraints
string fly_state
bool null_tracker
uint32 secs_flown

float32 odom_hz
int16 odom_color
float32 odom_x
float32 odom_y
float32 odom_z
float32 odom_hdg
string odom_frame
string[] odom_estimators_hori
string[] odom_estimators_vert
string[] odom_estimators_hdg

float32 cmd_x
float32 cmd_y
float32 cmd_z
float32 cmd_hdg

float32 cpu_load
float32 cpu_load_total
float32 cpu_ghz
float32 cpu_temperature
float32 free_ram
float32 total_ram
int32 free_hdd

float32 mavros_hz
int16 mavros_color
float32 mavros_battery_hz
float32 mavros_state_hz
float32 mavros_cmd_hz
string mavros_mode
bool mavros_armed
bool mavros_gps_ok
float32 mavros_gps_qual
float32 battery_volt
float32 battery_curr
float32 battery_wh_drained
float32 thrust
float32 mass_estimate
float32 mass_set

CustomTopic[] custom_topics
string[] custom_string_outputs
string[] custom_services

NodeCpuLoad node_cpu_loads

bool flying_normally
bool have_goal
bool callbacks_enabled
bool collision_avoidance_enabled
bool avoiding_collision
bool automatic_start_can_takeoff

uint16 num_other_uavs

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: mrs_msgs/CustomTopic
string topic_name
float32 topic_hz
int16 topic_color

================================================================================
MSG: mrs_msgs/NodeCpuLoad
string[] node_names
float32[] cpu_loads
"""
  __slots__ = ['header','uav_name','nato_name','uav_type','uav_mass','control_manager_diag_hz','control_manager_diag_color','controllers','gains','trackers','constraints','fly_state','null_tracker','secs_flown','odom_hz','odom_color','odom_x','odom_y','odom_z','odom_hdg','odom_frame','odom_estimators_hori','odom_estimators_vert','odom_estimators_hdg','cmd_x','cmd_y','cmd_z','cmd_hdg','cpu_load','cpu_load_total','cpu_ghz','cpu_temperature','free_ram','total_ram','free_hdd','mavros_hz','mavros_color','mavros_battery_hz','mavros_state_hz','mavros_cmd_hz','mavros_mode','mavros_armed','mavros_gps_ok','mavros_gps_qual','battery_volt','battery_curr','battery_wh_drained','thrust','mass_estimate','mass_set','custom_topics','custom_string_outputs','custom_services','node_cpu_loads','flying_normally','have_goal','callbacks_enabled','collision_avoidance_enabled','avoiding_collision','automatic_start_can_takeoff','num_other_uavs']
  _slot_types = ['std_msgs/Header','string','string','string','string','float32','int16','string[]','string[]','string[]','string[]','string','bool','uint32','float32','int16','float32','float32','float32','float32','string','string[]','string[]','string[]','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','int32','float32','int16','float32','float32','float32','string','bool','bool','float32','float32','float32','float32','float32','float32','float32','mrs_msgs/CustomTopic[]','string[]','string[]','mrs_msgs/NodeCpuLoad','bool','bool','bool','bool','bool','bool','uint16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,uav_name,nato_name,uav_type,uav_mass,control_manager_diag_hz,control_manager_diag_color,controllers,gains,trackers,constraints,fly_state,null_tracker,secs_flown,odom_hz,odom_color,odom_x,odom_y,odom_z,odom_hdg,odom_frame,odom_estimators_hori,odom_estimators_vert,odom_estimators_hdg,cmd_x,cmd_y,cmd_z,cmd_hdg,cpu_load,cpu_load_total,cpu_ghz,cpu_temperature,free_ram,total_ram,free_hdd,mavros_hz,mavros_color,mavros_battery_hz,mavros_state_hz,mavros_cmd_hz,mavros_mode,mavros_armed,mavros_gps_ok,mavros_gps_qual,battery_volt,battery_curr,battery_wh_drained,thrust,mass_estimate,mass_set,custom_topics,custom_string_outputs,custom_services,node_cpu_loads,flying_normally,have_goal,callbacks_enabled,collision_avoidance_enabled,avoiding_collision,automatic_start_can_takeoff,num_other_uavs

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(UavStatus, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.uav_name is None:
        self.uav_name = ''
      if self.nato_name is None:
        self.nato_name = ''
      if self.uav_type is None:
        self.uav_type = ''
      if self.uav_mass is None:
        self.uav_mass = ''
      if self.control_manager_diag_hz is None:
        self.control_manager_diag_hz = 0.
      if self.control_manager_diag_color is None:
        self.control_manager_diag_color = 0
      if self.controllers is None:
        self.controllers = []
      if self.gains is None:
        self.gains = []
      if self.trackers is None:
        self.trackers = []
      if self.constraints is None:
        self.constraints = []
      if self.fly_state is None:
        self.fly_state = ''
      if self.null_tracker is None:
        self.null_tracker = False
      if self.secs_flown is None:
        self.secs_flown = 0
      if self.odom_hz is None:
        self.odom_hz = 0.
      if self.odom_color is None:
        self.odom_color = 0
      if self.odom_x is None:
        self.odom_x = 0.
      if self.odom_y is None:
        self.odom_y = 0.
      if self.odom_z is None:
        self.odom_z = 0.
      if self.odom_hdg is None:
        self.odom_hdg = 0.
      if self.odom_frame is None:
        self.odom_frame = ''
      if self.odom_estimators_hori is None:
        self.odom_estimators_hori = []
      if self.odom_estimators_vert is None:
        self.odom_estimators_vert = []
      if self.odom_estimators_hdg is None:
        self.odom_estimators_hdg = []
      if self.cmd_x is None:
        self.cmd_x = 0.
      if self.cmd_y is None:
        self.cmd_y = 0.
      if self.cmd_z is None:
        self.cmd_z = 0.
      if self.cmd_hdg is None:
        self.cmd_hdg = 0.
      if self.cpu_load is None:
        self.cpu_load = 0.
      if self.cpu_load_total is None:
        self.cpu_load_total = 0.
      if self.cpu_ghz is None:
        self.cpu_ghz = 0.
      if self.cpu_temperature is None:
        self.cpu_temperature = 0.
      if self.free_ram is None:
        self.free_ram = 0.
      if self.total_ram is None:
        self.total_ram = 0.
      if self.free_hdd is None:
        self.free_hdd = 0
      if self.mavros_hz is None:
        self.mavros_hz = 0.
      if self.mavros_color is None:
        self.mavros_color = 0
      if self.mavros_battery_hz is None:
        self.mavros_battery_hz = 0.
      if self.mavros_state_hz is None:
        self.mavros_state_hz = 0.
      if self.mavros_cmd_hz is None:
        self.mavros_cmd_hz = 0.
      if self.mavros_mode is None:
        self.mavros_mode = ''
      if self.mavros_armed is None:
        self.mavros_armed = False
      if self.mavros_gps_ok is None:
        self.mavros_gps_ok = False
      if self.mavros_gps_qual is None:
        self.mavros_gps_qual = 0.
      if self.battery_volt is None:
        self.battery_volt = 0.
      if self.battery_curr is None:
        self.battery_curr = 0.
      if self.battery_wh_drained is None:
        self.battery_wh_drained = 0.
      if self.thrust is None:
        self.thrust = 0.
      if self.mass_estimate is None:
        self.mass_estimate = 0.
      if self.mass_set is None:
        self.mass_set = 0.
      if self.custom_topics is None:
        self.custom_topics = []
      if self.custom_string_outputs is None:
        self.custom_string_outputs = []
      if self.custom_services is None:
        self.custom_services = []
      if self.node_cpu_loads is None:
        self.node_cpu_loads = mrs_msgs.msg.NodeCpuLoad()
      if self.flying_normally is None:
        self.flying_normally = False
      if self.have_goal is None:
        self.have_goal = False
      if self.callbacks_enabled is None:
        self.callbacks_enabled = False
      if self.collision_avoidance_enabled is None:
        self.collision_avoidance_enabled = False
      if self.avoiding_collision is None:
        self.avoiding_collision = False
      if self.automatic_start_can_takeoff is None:
        self.automatic_start_can_takeoff = False
      if self.num_other_uavs is None:
        self.num_other_uavs = 0
    else:
      self.header = std_msgs.msg.Header()
      self.uav_name = ''
      self.nato_name = ''
      self.uav_type = ''
      self.uav_mass = ''
      self.control_manager_diag_hz = 0.
      self.control_manager_diag_color = 0
      self.controllers = []
      self.gains = []
      self.trackers = []
      self.constraints = []
      self.fly_state = ''
      self.null_tracker = False
      self.secs_flown = 0
      self.odom_hz = 0.
      self.odom_color = 0
      self.odom_x = 0.
      self.odom_y = 0.
      self.odom_z = 0.
      self.odom_hdg = 0.
      self.odom_frame = ''
      self.odom_estimators_hori = []
      self.odom_estimators_vert = []
      self.odom_estimators_hdg = []
      self.cmd_x = 0.
      self.cmd_y = 0.
      self.cmd_z = 0.
      self.cmd_hdg = 0.
      self.cpu_load = 0.
      self.cpu_load_total = 0.
      self.cpu_ghz = 0.
      self.cpu_temperature = 0.
      self.free_ram = 0.
      self.total_ram = 0.
      self.free_hdd = 0
      self.mavros_hz = 0.
      self.mavros_color = 0
      self.mavros_battery_hz = 0.
      self.mavros_state_hz = 0.
      self.mavros_cmd_hz = 0.
      self.mavros_mode = ''
      self.mavros_armed = False
      self.mavros_gps_ok = False
      self.mavros_gps_qual = 0.
      self.battery_volt = 0.
      self.battery_curr = 0.
      self.battery_wh_drained = 0.
      self.thrust = 0.
      self.mass_estimate = 0.
      self.mass_set = 0.
      self.custom_topics = []
      self.custom_string_outputs = []
      self.custom_services = []
      self.node_cpu_loads = mrs_msgs.msg.NodeCpuLoad()
      self.flying_normally = False
      self.have_goal = False
      self.callbacks_enabled = False
      self.collision_avoidance_enabled = False
      self.avoiding_collision = False
      self.automatic_start_can_takeoff = False
      self.num_other_uavs = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.nato_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_mass
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_fh().pack(_x.control_manager_diag_hz, _x.control_manager_diag_color))
      length = len(self.controllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.controllers:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.gains)
      buff.write(_struct_I.pack(length))
      for val1 in self.gains:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.trackers)
      buff.write(_struct_I.pack(length))
      for val1 in self.trackers:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.constraints)
      buff.write(_struct_I.pack(length))
      for val1 in self.constraints:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self.fly_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BIfh4f().pack(_x.null_tracker, _x.secs_flown, _x.odom_hz, _x.odom_color, _x.odom_x, _x.odom_y, _x.odom_z, _x.odom_hdg))
      _x = self.odom_frame
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.odom_estimators_hori)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_hori:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.odom_estimators_vert)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_vert:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.odom_estimators_hdg)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_hdg:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self
      buff.write(_get_struct_10fifh3f().pack(_x.cmd_x, _x.cmd_y, _x.cmd_z, _x.cmd_hdg, _x.cpu_load, _x.cpu_load_total, _x.cpu_ghz, _x.cpu_temperature, _x.free_ram, _x.total_ram, _x.free_hdd, _x.mavros_hz, _x.mavros_color, _x.mavros_battery_hz, _x.mavros_state_hz, _x.mavros_cmd_hz))
      _x = self.mavros_mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2B7f().pack(_x.mavros_armed, _x.mavros_gps_ok, _x.mavros_gps_qual, _x.battery_volt, _x.battery_curr, _x.battery_wh_drained, _x.thrust, _x.mass_estimate, _x.mass_set))
      length = len(self.custom_topics)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_topics:
        _x = val1.topic_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_fh().pack(_x.topic_hz, _x.topic_color))
      length = len(self.custom_string_outputs)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_string_outputs:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.custom_services)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_services:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.node_cpu_loads.node_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.node_cpu_loads.node_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.node_cpu_loads.cpu_loads)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.node_cpu_loads.cpu_loads))
      _x = self
      buff.write(_get_struct_6BH().pack(_x.flying_normally, _x.have_goal, _x.callbacks_enabled, _x.collision_avoidance_enabled, _x.avoiding_collision, _x.automatic_start_can_takeoff, _x.num_other_uavs))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.custom_topics is None:
        self.custom_topics = None
      if self.node_cpu_loads is None:
        self.node_cpu_loads = mrs_msgs.msg.NodeCpuLoad()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.nato_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.nato_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_type = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_mass = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_mass = str[start:end]
      _x = self
      start = end
      end += 6
      (_x.control_manager_diag_hz, _x.control_manager_diag_color,) = _get_struct_fh().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.controllers = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.controllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gains = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.gains.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trackers = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.trackers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.constraints = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.constraints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.fly_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.fly_state = str[start:end]
      _x = self
      start = end
      end += 27
      (_x.null_tracker, _x.secs_flown, _x.odom_hz, _x.odom_color, _x.odom_x, _x.odom_y, _x.odom_z, _x.odom_hdg,) = _get_struct_BIfh4f().unpack(str[start:end])
      self.null_tracker = bool(self.null_tracker)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom_frame = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom_frame = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_hori = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_hori.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_vert = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_vert.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_hdg = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_hdg.append(val1)
      _x = self
      start = end
      end += 62
      (_x.cmd_x, _x.cmd_y, _x.cmd_z, _x.cmd_hdg, _x.cpu_load, _x.cpu_load_total, _x.cpu_ghz, _x.cpu_temperature, _x.free_ram, _x.total_ram, _x.free_hdd, _x.mavros_hz, _x.mavros_color, _x.mavros_battery_hz, _x.mavros_state_hz, _x.mavros_cmd_hz,) = _get_struct_10fifh3f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mavros_mode = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mavros_mode = str[start:end]
      _x = self
      start = end
      end += 30
      (_x.mavros_armed, _x.mavros_gps_ok, _x.mavros_gps_qual, _x.battery_volt, _x.battery_curr, _x.battery_wh_drained, _x.thrust, _x.mass_estimate, _x.mass_set,) = _get_struct_2B7f().unpack(str[start:end])
      self.mavros_armed = bool(self.mavros_armed)
      self.mavros_gps_ok = bool(self.mavros_gps_ok)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_topics = []
      for i in range(0, length):
        val1 = mrs_msgs.msg.CustomTopic()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.topic_name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.topic_name = str[start:end]
        _x = val1
        start = end
        end += 6
        (_x.topic_hz, _x.topic_color,) = _get_struct_fh().unpack(str[start:end])
        self.custom_topics.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_string_outputs = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.custom_string_outputs.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_services = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.custom_services.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.node_cpu_loads.node_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.node_cpu_loads.node_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.node_cpu_loads.cpu_loads = s.unpack(str[start:end])
      _x = self
      start = end
      end += 8
      (_x.flying_normally, _x.have_goal, _x.callbacks_enabled, _x.collision_avoidance_enabled, _x.avoiding_collision, _x.automatic_start_can_takeoff, _x.num_other_uavs,) = _get_struct_6BH().unpack(str[start:end])
      self.flying_normally = bool(self.flying_normally)
      self.have_goal = bool(self.have_goal)
      self.callbacks_enabled = bool(self.callbacks_enabled)
      self.collision_avoidance_enabled = bool(self.collision_avoidance_enabled)
      self.avoiding_collision = bool(self.avoiding_collision)
      self.automatic_start_can_takeoff = bool(self.automatic_start_can_takeoff)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.nato_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.uav_mass
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_fh().pack(_x.control_manager_diag_hz, _x.control_manager_diag_color))
      length = len(self.controllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.controllers:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.gains)
      buff.write(_struct_I.pack(length))
      for val1 in self.gains:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.trackers)
      buff.write(_struct_I.pack(length))
      for val1 in self.trackers:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.constraints)
      buff.write(_struct_I.pack(length))
      for val1 in self.constraints:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self.fly_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BIfh4f().pack(_x.null_tracker, _x.secs_flown, _x.odom_hz, _x.odom_color, _x.odom_x, _x.odom_y, _x.odom_z, _x.odom_hdg))
      _x = self.odom_frame
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.odom_estimators_hori)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_hori:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.odom_estimators_vert)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_vert:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.odom_estimators_hdg)
      buff.write(_struct_I.pack(length))
      for val1 in self.odom_estimators_hdg:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self
      buff.write(_get_struct_10fifh3f().pack(_x.cmd_x, _x.cmd_y, _x.cmd_z, _x.cmd_hdg, _x.cpu_load, _x.cpu_load_total, _x.cpu_ghz, _x.cpu_temperature, _x.free_ram, _x.total_ram, _x.free_hdd, _x.mavros_hz, _x.mavros_color, _x.mavros_battery_hz, _x.mavros_state_hz, _x.mavros_cmd_hz))
      _x = self.mavros_mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2B7f().pack(_x.mavros_armed, _x.mavros_gps_ok, _x.mavros_gps_qual, _x.battery_volt, _x.battery_curr, _x.battery_wh_drained, _x.thrust, _x.mass_estimate, _x.mass_set))
      length = len(self.custom_topics)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_topics:
        _x = val1.topic_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_fh().pack(_x.topic_hz, _x.topic_color))
      length = len(self.custom_string_outputs)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_string_outputs:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.custom_services)
      buff.write(_struct_I.pack(length))
      for val1 in self.custom_services:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.node_cpu_loads.node_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.node_cpu_loads.node_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.node_cpu_loads.cpu_loads)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.node_cpu_loads.cpu_loads.tostring())
      _x = self
      buff.write(_get_struct_6BH().pack(_x.flying_normally, _x.have_goal, _x.callbacks_enabled, _x.collision_avoidance_enabled, _x.avoiding_collision, _x.automatic_start_can_takeoff, _x.num_other_uavs))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.custom_topics is None:
        self.custom_topics = None
      if self.node_cpu_loads is None:
        self.node_cpu_loads = mrs_msgs.msg.NodeCpuLoad()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.nato_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.nato_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_type = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.uav_mass = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.uav_mass = str[start:end]
      _x = self
      start = end
      end += 6
      (_x.control_manager_diag_hz, _x.control_manager_diag_color,) = _get_struct_fh().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.controllers = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.controllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gains = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.gains.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trackers = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.trackers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.constraints = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.constraints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.fly_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.fly_state = str[start:end]
      _x = self
      start = end
      end += 27
      (_x.null_tracker, _x.secs_flown, _x.odom_hz, _x.odom_color, _x.odom_x, _x.odom_y, _x.odom_z, _x.odom_hdg,) = _get_struct_BIfh4f().unpack(str[start:end])
      self.null_tracker = bool(self.null_tracker)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom_frame = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom_frame = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_hori = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_hori.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_vert = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_vert.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.odom_estimators_hdg = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.odom_estimators_hdg.append(val1)
      _x = self
      start = end
      end += 62
      (_x.cmd_x, _x.cmd_y, _x.cmd_z, _x.cmd_hdg, _x.cpu_load, _x.cpu_load_total, _x.cpu_ghz, _x.cpu_temperature, _x.free_ram, _x.total_ram, _x.free_hdd, _x.mavros_hz, _x.mavros_color, _x.mavros_battery_hz, _x.mavros_state_hz, _x.mavros_cmd_hz,) = _get_struct_10fifh3f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mavros_mode = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.mavros_mode = str[start:end]
      _x = self
      start = end
      end += 30
      (_x.mavros_armed, _x.mavros_gps_ok, _x.mavros_gps_qual, _x.battery_volt, _x.battery_curr, _x.battery_wh_drained, _x.thrust, _x.mass_estimate, _x.mass_set,) = _get_struct_2B7f().unpack(str[start:end])
      self.mavros_armed = bool(self.mavros_armed)
      self.mavros_gps_ok = bool(self.mavros_gps_ok)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_topics = []
      for i in range(0, length):
        val1 = mrs_msgs.msg.CustomTopic()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.topic_name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.topic_name = str[start:end]
        _x = val1
        start = end
        end += 6
        (_x.topic_hz, _x.topic_color,) = _get_struct_fh().unpack(str[start:end])
        self.custom_topics.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_string_outputs = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.custom_string_outputs.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.custom_services = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.custom_services.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.node_cpu_loads.node_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.node_cpu_loads.node_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.node_cpu_loads.cpu_loads = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 8
      (_x.flying_normally, _x.have_goal, _x.callbacks_enabled, _x.collision_avoidance_enabled, _x.avoiding_collision, _x.automatic_start_can_takeoff, _x.num_other_uavs,) = _get_struct_6BH().unpack(str[start:end])
      self.flying_normally = bool(self.flying_normally)
      self.have_goal = bool(self.have_goal)
      self.callbacks_enabled = bool(self.callbacks_enabled)
      self.collision_avoidance_enabled = bool(self.collision_avoidance_enabled)
      self.avoiding_collision = bool(self.avoiding_collision)
      self.automatic_start_can_takeoff = bool(self.automatic_start_can_takeoff)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_10fifh3f = None
def _get_struct_10fifh3f():
    global _struct_10fifh3f
    if _struct_10fifh3f is None:
        _struct_10fifh3f = struct.Struct("<10fifh3f")
    return _struct_10fifh3f
_struct_2B7f = None
def _get_struct_2B7f():
    global _struct_2B7f
    if _struct_2B7f is None:
        _struct_2B7f = struct.Struct("<2B7f")
    return _struct_2B7f
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_6BH = None
def _get_struct_6BH():
    global _struct_6BH
    if _struct_6BH is None:
        _struct_6BH = struct.Struct("<6BH")
    return _struct_6BH
_struct_BIfh4f = None
def _get_struct_BIfh4f():
    global _struct_BIfh4f
    if _struct_BIfh4f is None:
        _struct_BIfh4f = struct.Struct("<BIfh4f")
    return _struct_BIfh4f
_struct_fh = None
def _get_struct_fh():
    global _struct_fh
    if _struct_fh is None:
        _struct_fh = struct.Struct("<fh")
    return _struct_fh
